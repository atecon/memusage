function scalar memusage (const bundle b,
						const bool print_value[FALSE]))
	/* Wrapper function passing a single variable of _any_ data type through a bundle. The data type of the passed variable is determined, and the corresponding function is called then.
	return: scalar (memory size in MB) if valid bundle is passed, otherwise NA. */

	if nelem(b) != 1
		printf "\nWarning: The bundle must include a single item.\n"
		return NA
	else
		string key = getkeys(b)[1]
	endif

	if typestr(typeof(b["@key"])) == "bundle"
		return memusage_bundle(b["@key"], print_value)
	elif typestr(typeof(b["@key"])) == "matrix"
		return memusage_matrix(b["@key"], print_value)
	elif typestr(typeof(b["@key"])) == "array"
		catch scalar mb = memusage_matrices(b["@key"], print_value)
		if $error
			scalar mb = memusage_strings(b["@key"], print_value)
		endif
		return mb
	elif typestr(typeof(b["@key"])) == "series"
		return memusage_series(b["@key"], print_value)
	elif typestr(typeof(b["@key"])) == "list"
		return memusage_list(b["@key"], print_value)
	elif typestr(typeof(b["@key"])) == "string"
		return memusage_string(b["@key"], print_value)
	endif
end function

function scalar memusage_bundle (const bundle b,
								const bool print_value[FALSE])
	/* Compute memory usage of all items in a bundle.
	return: scalar, in MB */

	scalar memory = 0
	loop foreach i b
		if typeof(b["$i"]) == 1
			memory += compute_memory(1)
		elif typeof(b["$i"]) == 2
			memory += memusage_series(b["$i"])
		elif typeof(b["$i"]) == 3
			memory += memusage_matrix(b["$i"])
		elif typeof(b["$i"]) == 4
			memory += memusage_string(b["$i"])
		elif typeof(b["$i"]) == 6
			memory += memusage_strings(b["$i"])
		elif typeof(b["$i"]) == 7
			memory += memusage_list(b["$i"])
		endif
	endloop

	print_memusage(argname(b), memory, "bundle", print_value)

	return memory
end function


function scalar memusage_matrix (const matrix m,
								const bool print_value[FALSE])
	/* Compute memory usage of matrix.
	return: scalar, in MB */

	scalar memory = compute_memory(nelem(m))
	print_memusage(argname(m), memory, "matrix", print_value)

	return memory
end function

function scalar memusage_string (const string s,
								const bool print_value[FALSE])
	/* Compute (approximate) memory usage of a string. If ASCII, one byte per character; if UTF-8 it depends, at least one byte but up to 4 per character.

	return: scalar, in MB */

	scalar memory = compute_memory(nelem(s))
	print_memusage(argname(s), memory, "string", print_value)

	return memory
end function

function scalar memusage_strings (const strings s,
								const bool print_value[FALSE])
	/* Compute memory usage of a string array.
	return: scalar, in MB */

	string str = ""
	loop foreach i s
		str += s[i]
	endloop
	scalar memory = compute_memory(nelem(s))
	print_memusage(argname(s), memory, "strings", print_value)

	return memory
end function


# TODO: How does a string-valued series behave?
function scalar memusage_series (const series y,
								const bool print_value[FALSE])
	/* Compute memory usage of series.
	return: scalar, in MB */

	# TODO how much memory does NA use?
	scalar memory = compute_memory(nobs(y))
	print_memusage(argname(y), memory, "series", print_value)

	return memory
end function

function scalar memusage_matrices (const matrices M,
									const bool print_value[FALSE])
	/* Compute memory usage of an array of matrices.
	return: scalar, in MB */

	# TODO how much memory does NA use?
	scalar memory = 0
	loop i=1..nelem(M)
		memory += compute_memory(nelem(M[i]))
	endloop
	print_memusage(argname(M), memory, "matrices", print_value)

	return memory
end function


function scalar memusage_list (const list L,
								const bool print_value[FALSE])
	/* Compute memory usage of all list members.
	return: scalar, in MB */

	# TODO how much memory does NA use?
	scalar memory = 0
	loop foreach i L
		memory += compute_memory(nobs(L.$i))
	endloop
	print_memusage(argname(L), memory, "list", print_value)

	return memory
end function


function scalar compute_memory (const int n_vals)
	/* Compute memory usage.
	return: scalar, Usage in megabytes. */

	return size_in_mb(n_vals)
end function


function scalar size_in_mb (const int n_vals)
	/* Compute for a number of floating values, the associated memory on megabytes. Gretl stores matrix in double-precision format. Each float is of size 8 byte. Thus, the matrix will consume <(100000 * 32 * 8) / 1024 / 1024 = 24.4 MB>.
	return: scalar, size of object in MB */

	return (n_vals * 8) / 1024 / 1024
end function


function void print_memusage (const string variable_name,
							const scalar memory,
							const string datatype,
							const bool print_value)
	/* Print memory usage.
	return: void */

	if print_value == TRUE
		printf "\nInfo: Size of %s %s: %g MB.\n", datatype, variable_name, memory
	endif
end function
